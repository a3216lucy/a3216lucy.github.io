<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TailwindCSS 逐步上手</title>
    <url>/2022/01/19/Tailwind/</url>
    <content><![CDATA[<p>正好想學，在研究之餘，順便寫個教學留個紀錄。</p>
<h2 id="Tailwind-安裝流程-（使用-npm）"><a href="#Tailwind-安裝流程-（使用-npm）" class="headerlink" title="Tailwind 安裝流程 （使用 npm）"></a>Tailwind 安裝流程 （使用 npm）</h2><p>依照 <a href="https://tailwindcss.com/docs/installation">Tailwind 的官網</a>，安裝有兩種方式：</p>
<ul>
<li>使用 CDN</li>
<li>使用 npm</li>
</ul>
<p>而今天主要是以 npm 的方式來展示。</p>
<p>因為 Tailwind 若是靠 CDN 的方式，會導致很多強大的功能沒有全開，我們這邊就簡單舉例幾個：</p>
<ul>
<li>基本的，就是無法 <strong>新增自訂顏色</strong> 跟 <strong>支援深色模式</strong>。</li>
<li>再進階一點，就是無法使用 <strong><code>`@apply`</code></strong> 指令將語法整理起來。</li>
<li>最嚴重的，就是 <strong>無法壓縮檔案</strong>，CDN 版大小約 2.79MB。 （完整版約 3.7MB~4MB）</li>
</ul>
<p>所以如果只是為了 <strong>玩玩、體驗 Tailwind 的特性及帶來的方便性</strong>，完全可以<strong>使用 CDN</strong> 的方式就好，但如果是想要做公司產品／成品上線，這個沒壓縮的大小很有可能讓你被火了XDDD</p>
<h2 id="前置作業-安裝-node-js"><a href="#前置作業-安裝-node-js" class="headerlink" title="前置作業 - 安裝 node.js"></a>前置作業 - 安裝 node.js</h2><p>首先，如果你會用 linux 類系統，這個你肯定用過。<br>不過新手們的話就別跳過，還是都跑一遍吧，以免你有指令沒跑到或東西沒裝到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt update<br></code></pre></td></tr></table></figure>

<p>接著，這個很重要，要安裝 curl。 因為等一下就要靠他了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install curl<br></code></pre></td></tr></table></figure>

<p>再來，使用到剛剛安裝的 curl，把 node.js 12版的安裝腳本下載下來。請注意，這邊一定要抓12版或更新的！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -<br></code></pre></td></tr></table></figure>

<p>這下，就可以放心的把 node.js 安裝下去了~</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install nodejs<br></code></pre></td></tr></table></figure>

<h2 id="安裝-Tailwind"><a href="#安裝-Tailwind" class="headerlink" title="安裝 Tailwind"></a>安裝 Tailwind</h2><blockquote>
<p>注意：Tailwind CSS 需要 Node.js 版本在 12.13.0 以上</p>
</blockquote>
<ol>
<li>首先，因為 Thailwind 有 node.js 的版本限制，可以先執行以下的指令檢查 node.js 的版本。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">node --version<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>如果檢查完，確定 node 是 12 版以上，那就可以放心地執行下面這行指令了。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm init<br></code></pre></td></tr></table></figure>

<p>在打入 <code>NPM init</code> 後，會被要求輸入幾個欄位</p>
<blockquote>
<p><code>package name</code>: 你這個 Project 要叫什麼名字<br><code>version</code>: 你決定這個 Project 現在該是第幾版<br><code>description</code>: Project 基本介紹<br><code>entry point</code>: 進入點，如果要跑你的 Project 應該要執行哪個檔案<br><code>author</code>: 作者（自己）<br><code>license</code>: 你這個 Project 是採用什麼授權的<br><code>test command</code>: 這個不太重要，待會會說明</p>
</blockquote>
<p>基本上結束後，你可以看到這個資料夾底下，新增了一個 <code>Package.json</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-project&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;this is my project&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;app.js&quot;</span>,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;Kimi&quot;</span>,<br>  <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>基本上使用 NPM 來創建的 Project，他會連一些專案的資訊都幫你做管理。</p>
<blockquote>
<p><strong>Optional Info</strong>：<br>如果你覺得上面要一直輸入很冗，可以使用  <code>npm init -y</code> 。<br>他跟  <code>npm init</code>  幾乎一樣，只是它會幫你把預設選項全部跳過，產生一個空白的 <code>package.json</code> （懶人專用）</p>
</blockquote>
<ol start="3">
<li>接著， 依照官方教學，需安裝 Tailwind CSS、PostCSS，還有 autoprefixer 這三個檔案；因為 Tailwind 不會自動加上瀏覽器前缀詞到產生的 CSS 中，所以瀏覽器無法讀取 CSS，要加上 autoprefixer 這個套件去處理此問題。<br>我們使用一行指令就三個安裝好了，輕鬆愉快。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install tailwindcss@latest postcss@latest autoprefixer@latest<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>再來，為了以防萬一，我們執行一次 <code>`npm install`</code> 來更新和安裝其他依賴套件的狀態。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install<br></code></pre></td></tr></table></figure>

<p>那這樣就算安裝完了，只是距離使用，中間還有一些東西需要設定。<br>如果你還會透過 postCSS 安裝其他插件、或是像官方的推薦使用 autoprefixer的話，可以看一下下方的 **安裝 PostCSS 套件。</p>
<h3 id="Optional-Info"><a href="#Optional-Info" class="headerlink" title="Optional Info"></a>Optional Info</h3><p>如果在安裝過程中，有遇到以下錯誤，那可能是 <strong>將 Tailwind 與舊版本的 PostCSS 混合使用</strong> 所導致的結果， v2.0 版本的 Tailwind 依賴於 PostCSS 8。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Error: PostCSS plugin tailwindcss requires PostCSS 8.<br></code></pre></td></tr></table></figure>

<p>這時請安裝 <a href="https://www.tailwindcss.cn/docs/installation#post-css-7">PostCSS 7</a> 版本，才能兼容。</p>
<hr>

<h4 id="安裝-PostCSS-7"><a href="#安裝-PostCSS-7" class="headerlink" title="安裝 PostCSS 7"></a>安裝 PostCSS 7</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm uninstall tailwindcss<br>npm install tailwindcss@npm:@tailwindcss/postcss7-compat<br></code></pre></td></tr></table></figure>

<hr>

<h4 id="安裝-PostCSS-套件"><a href="#安裝-PostCSS-套件" class="headerlink" title="安裝 PostCSS 套件"></a>安裝 PostCSS 套件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install tailwindcss autoprefixer postcss postcss-cli<br></code></pre></td></tr></table></figure>

<p>上面這個指令，就是幫你的專案透過 npm 安裝 tailwindcss、postcss、autoprefixer，及 postcss-cli 這四個東西。<br>那如果有看過官方教學，對前三個東西應該不陌生，只是最後一個也是必須的，算是幫官方安裝過程的補充。</p>
<p>在前面的步驟產生完 Tailwind 設定檔之後，我們要來產生 PostCSS 的設定檔，不然 PostCSS 不會幫我們載入 tailwind 和 autoprefixer。</p>
<ul>
<li><strong>Windows用戶</strong></li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">在專案目錄下新增檔案 -&gt; 檔名為 <span class="hljs-string">&quot;postcss.config.js&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Linux、Ubuntu、MacOS 類用戶</strong>，直接下指令即可（ 在專案目錄下）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">touch postcss.config.js<br></code></pre></td></tr></table></figure>

<p>新增完 <code>`postcss.config.js`</code>，我們要在檔案中加入下面的內容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// postcss.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;tailwindcss&#x27;</span>),<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或是用官方給的格式也可以~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// postcss.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-attr">tailwindcss</span>: &#123;&#125;,<br>    <span class="hljs-attr">autoprefixer</span>: &#123;&#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最後的最後，只要把前面設定執行的地方，改成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">scripts</span>:[<br>    <span class="hljs-comment">/* ... 前面是你其它的設定值，略 .... */</span><br>    <span class="hljs-string">&quot;&#123; 你的執行名稱 &#125;&quot;</span>: <span class="hljs-string">&quot;postcss &#123;你 css 檔擺放的路徑&#125;/&#123;要寫樣式的css檔名稱&#125; -o &#123;你 css 檔擺放的路徑&#125;/&#123;頁面要掛載的css檔名稱&#125;&quot;</span><br>],<br></code></pre></td></tr></table></figure>

<p>剩下的步驟，都跟上面 tailwind 的教學一樣囉~</p>
<h2 id="設定-Tailwind"><a href="#設定-Tailwind" class="headerlink" title="設定 Tailwind"></a>設定 Tailwind</h2><ol>
<li>依照上方的流程，安裝完 Tailwind 應該會看到 <code>package.json</code> 中有新增後來安裝的 Tailwind CSS、PostCSS 和 autoprefixer。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;autoprefixer&quot;</span>: <span class="hljs-string">&quot;^10.2.6&quot;</span>,<br>    <span class="hljs-string">&quot;postcss&quot;</span>: <span class="hljs-string">&quot;^8.3.0&quot;</span>,<br>    <span class="hljs-string">&quot;tailwindcss&quot;</span>: <span class="hljs-string">&quot;^2.1.4&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>在使用 Tailwind CSS 之前，我們得產生 tailwind 必要的設定檔，這也是要達到 tailwind 客製化前最重要的一步。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npx tailwindcss init<br></code></pre></td></tr></table></figure>

<p>執行上方的指令後，在專案目錄下應該會多出一個叫做 <code>`tailwind.config.js`</code> 的檔案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">purge</span>: [],<br>  <span class="hljs-attr">darkMode</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// or &#x27;media&#x27; or &#x27;class&#x27;</span><br>  <span class="hljs-attr">theme</span>: &#123;<br>    <span class="hljs-attr">extend</span>: &#123;&#125;,<br>  &#125;,<br>  <span class="hljs-attr">variants</span>: &#123;<br>    <span class="hljs-attr">extend</span>: &#123;&#125;,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [],<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>這麼一來，就可以自訂專屬於你的 Tailwind 設定了！</p>
<h2 id="新增-Tailwind-到-CSS-中"><a href="#新增-Tailwind-到-CSS-中" class="headerlink" title="新增 Tailwind 到 CSS 中"></a>新增 Tailwind 到 CSS 中</h2><p>現在需要在你存放 CSS 樣式檔的資料夾裡，建立兩個 CSS 檔：</p>
<ul>
<li>一個是你頁面要掛載的 <code>style.css</code> （名稱可自訂）</li>
<li>一個是用來寫 CSS 樣式的 <code>tailwind.css</code> （名稱也可自訂）</li>
</ul>
<p>這樣講可能有點抽象，拿我的專案目錄來舉例好了。</p>
<p><img src="https://i.imgur.com/SLrk4vo.png"></p>
<p>在我的專案下，擺放 CSS 檔的路徑是 <code>/public/css</code> ，那就在這個資料夾底下產生兩個 CSS檔，名稱自訂，我這邊是把要掛載的叫做 <code>app.css</code>，要寫樣式內容的叫做 <code>tailwind.css</code>。</p>
<p>建立完之後，我們在要用來寫樣式的 CSS 檔 （我這邊叫做 <code>tailwind.css</code> ）裡面貼上下面的 CSS 語法。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 貼在用來寫樣式的css檔，範例這邊是 tailwind.css */</span><br><br><span class="hljs-keyword">@tailwind</span> base; <br><span class="hljs-keyword">@tailwind</span> components; <br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我們要掛載的 CSS 檔 (這邊叫做 <code>app.css</code>) 保持空白就好，以後所有要補充的樣式都寫在另一個 CSS 檔（<code>tailwind.css</code>）裡。<br>因為如果接下來 <strong>進行編譯</strong>， 要掛載的 CSS 檔 (<code>app.css</code>) 的 <strong>內容會被覆蓋掉</strong>。</p>
</blockquote>
<h2 id="編譯"><a href="#編譯" class="headerlink" title="編譯"></a>編譯</h2><p>終於進入最後一步了。<br>開啟剛剛 <code>`npm init`</code> 執行後產生的 <code>package.json</code>，在 scripts 裡面加一行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">scripts</span>:[<br>    <span class="hljs-comment">/* ... 前面是你其它的設定值，略 .... */</span><br>    <span class="hljs-string">&quot;&#123; 你的執行名稱 &#125;&quot;</span>: <span class="hljs-string">&quot;tailwind build &#123;你 css 檔擺放的路徑&#125;/&#123;要寫樣式的css檔名稱&#125; -o &#123;你 css 檔擺放的路徑&#125;/&#123;頁面要掛載的css檔名稱&#125;&quot;</span><br>],<br></code></pre></td></tr></table></figure>

<p>如果把上述的名稱都取代完之後，在我這邊的範例，會長的像下面這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">scripts</span>:[<br>    <span class="hljs-comment">/* ... 前面是你其它的設定值，略 .... */</span><br>    <span class="hljs-string">&quot;build-css&quot;</span>: <span class="hljs-string">&quot;tailwind build public/css/tailwind.css -o public/css/app.css&quot;</span><br>],<br></code></pre></td></tr></table></figure>

<p>最後，我們只要執行 <code>npm run &#123;你的執行名稱&#125;</code>，那他就會開始進行編譯了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm run build-css<br></code></pre></td></tr></table></figure>

<p>編譯完成後，應該會在命令列 (終端機) 看到下面的訊息：</p>
<p><img src="https://i.imgur.com/vYO0NIn.png"></p>
<p>這樣就算編譯完成了，現在只要你在頁面掛上要掛載的 CSS 檔，並用上 Tailwind 語法，就會有效果囉！</p>
<h2 id="使用-Tailwind-CSS"><a href="#使用-Tailwind-CSS" class="headerlink" title="使用 Tailwind CSS"></a>使用 Tailwind CSS</h2><p>在你網頁中插入的 CSS 檔路徑要改成剛剛上面說過的，用來掛載在頁面上的 CSS 檔。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 你專案中要使用 Tailwind CSS 的頁面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 前略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./&#123;你CSS檔的路徑&#125;/&#123;要掛載在頁面的CSS檔名稱&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 略 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>底下這邊是我依照我專案所改寫後的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 這範例是我專案中的 index.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 前略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./css/app.css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 馬上用 Tailwind 寫一個熱騰騰的黃綠藍三色漸層 Hello World 方塊 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;m-3 p-10 bg-gradient-to-r from-yellow-400 via-green-400 to-blue-400 text-white&quot;</span>&gt;</span><br>          Hello World ! I&#x27;m using Tailwind CSS Now ~<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>這樣就把 Tailwind CSS 安裝完了，這樣你就可以盡情地使用 Tailwind 寫出一堆美美的介面了啦！</p>
<h2 id="Optional：幫-CSS-瘦身"><a href="#Optional：幫-CSS-瘦身" class="headerlink" title="Optional：幫 CSS 瘦身"></a>Optional：幫 CSS 瘦身</h2><p>Tailwind 因為是 Utility 的關係，會把整包檔案匯入，如果整包檔案要選染於網頁，效能就會低落。</p>
<p>Tailwind 官方文件有提供可以瘦身的方法：</p>
<ol>
<li>選到 <code>tailwind.config.js</code> 檔案，將我可能會使用到的內容寫在  <code>purge</code> 屬性內</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//tailwind.config.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">purge</span>: &#123;<br>    <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">content</span>: [<span class="hljs-string">&quot;./**/*.html&quot;</span>],<br>  &#125;,<br>  <span class="hljs-attr">darkMode</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// or &#x27;media&#x27; or &#x27;class&#x27;</span><br>  <span class="hljs-attr">theme</span>: &#123;<br>    <span class="hljs-attr">extend</span>: &#123;&#125;,<br>  &#125;,<br>  <span class="hljs-attr">variants</span>: &#123;<br>    <span class="hljs-attr">extend</span>: &#123;&#125;,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [],<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>這樣程式執行時，就會去監聽我哪支檔案有使用到，只會編譯使用的檔案，真的很方便！</li>
</ol>
]]></content>
      <categories>
        <category>技術筆記</category>
      </categories>
      <tags>
        <tag>教學</tag>
        <tag>技術文件</tag>
        <tag>TailwindCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【心得分享】寫在活動之後</title>
    <url>/2021/09/30/pm361_activity/</url>
    <content><![CDATA[<p>身為活動的 PO，很高興能夠邀請到硬體業 PM Eva 和軟體業 PM Rafeni 來和大家分享他們的經歷。</p>
<p><img src="https://miro.medium.com/max/1400/1*oEIRVqvHSzxU-h9ugsPSKQ.png"></p>
<p style="text-align:center"><i>活動 ：PM 相談室《新手篇》</i></p>

<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><blockquote>
<p>筆者隸屬於 PM361 社群，近期於 2021&#x2F;09 月時舉辦了「PM 相談室《新手篇》」活動，主要的 TA 為那些想要轉職 PM 或剛入行的新手 PM 們。<br>我們希望能夠透過有經驗者的分享，來幫助他們解決一些常見的疑惑、瞭解 PM 的工作職務，因而對 PM 的認知有個基礎的架構。</p>
</blockquote>
<p><br>因為在活動中的身份不太一樣，此篇文章主要會以「籌劃者」的角度來回顧活動，而非分享活動心得體驗，大綱可分為以下幾個部分：</p>
<ul>
<li>活動的初衷</li>
<li>主題挑選與聚焦</li>
<li>活動檢討與回饋</li>
</ul>
<h2 id="活動的初衷"><a href="#活動的初衷" class="headerlink" title="活動的初衷"></a>活動的初衷</h2><p>說到 PM 361 社群 ，社團成立的衷旨為<em><strong>「期許 PM 們擁有 360 ° 的全方位視野，加上 1° 自己的觀點」</strong></em>，讓同為 PM 的這群同溫層有個平台可以互相交流、成長。</p>
<p>而在我加入社群後，也一直為著這個目標努力著，和成員們除了透過每月舉辦的活動，分享 PM 相關知識與議題，也不斷在關注著社團內的需求與動向。</p>
<p>在分析社團成員的組成與面向後，我們發現主要的 TA 大多為：</p>
<ul>
<li>對 PM 有興趣、欲轉職為 PM 者（本身非 PM 或為新鮮人）</li>
<li>0 - 3 年的新手 PM</li>
</ul>
<p>其分別的痛點大致如下：</p>
<h3 id="對-PM-有興趣、欲轉職為-PM-者"><a href="#對-PM-有興趣、欲轉職為-PM-者" class="headerlink" title="對 PM 有興趣、欲轉職為 PM 者"></a>對 PM 有興趣、欲轉職為 PM 者</h3><ul>
<li>不清楚 PM 的工作職能</li>
<li>找不到 PM 前輩可以請教</li>
<li>不知道自己是否適合、能否勝任這個職位</li>
<li>不知道特定產業的 PM 差別</li>
<li>有薪資上的需求（高薪）</li>
</ul>
<h3 id="0-3-年的新手-PM"><a href="#0-3-年的新手-PM" class="headerlink" title="0 - 3 年的新手 PM"></a>0 - 3 年的新手 PM</h3><ul>
<li>對產品策略與規劃不熟悉，沒有好的思考框架</li>
<li>溝通問題（向上管理、跨部門協作）</li>
<li>無系統化學習（學習管道、專業技能）</li>
<li>不知道如何提升工作效率（工具、方法模型的使用）</li>
<li>職涯規劃（履歷、面試技巧）</li>
</ul>
<p>為了滿足上述的需求，才規劃了此次的活動。</p>
<h2 id="主題挑選與聚焦"><a href="#主題挑選與聚焦" class="headerlink" title="主題挑選與聚焦"></a>主題挑選與聚焦</h2><p>在確定了活動的 TA 與大方向後，我首先針對「產業別」來挑選適合的講師，最終鎖定「硬體業」和「軟體業」。<br>除了希望能對比做出差異化之外，這兩個也算是市場普遍的兩大產業。（當然未來有機會的話，也可以瞄準電商、醫療等領域）</p>
<p>起初設定的分享內容會相對深一點，適合有一些基礎的對象參與，不過在瀏覽報名者的回饋與疑惑後，發現普遍都對 PM 沒概念，才調整以「知識普及」、「觀念建立」、「框架分享」為導向，列出幾個關鍵標籤：</p>
<ul>
<li>轉職／求職</li>
<li>PM 工作職能介紹</li>
<li>溝通與協作</li>
</ul>
<p>也就是大家現在看到的版本，而過程中也和講師們協調過多次，最終才定稿。<br>P.S. 真的特別感謝講師們的配合，花了很多時間討論與修改內容，真的是人美又心善，辛苦了！！</p>
<h2 id="活動檢討與回饋"><a href="#活動檢討與回饋" class="headerlink" title="活動檢討與回饋"></a>活動檢討與回饋</h2><p>接著來談談活動後，回顧整場活動：</p>
<h3 id="1-參與度"><a href="#1-參與度" class="headerlink" title="1. 參與度"></a>1. 參與度</h3><p>從出席率和活動過程來看，與會者的參與度還算高，都蠻認真的在聽講師分享，不過因爲此場活動沒有開放「現場互動」，而是採用「單方面文字回饋」，無法反應「活躍度」與「互動率」，這點確實蠻可惜的。</p>
<h3 id="2-控場與節奏"><a href="#2-控場與節奏" class="headerlink" title="2. 控場與節奏"></a>2. 控場與節奏</h3><p>身為 PO 兼主持人，我必須先承認在節奏與氛圍上，有很多地方需要再改進，流程、平台工具、主持切換、背景音樂等部分都有優化的空間，之後會再重點留意。</p>
<h3 id="3-參與者回饋"><a href="#3-參與者回饋" class="headerlink" title="3. 參與者回饋"></a>3. 參與者回饋</h3><p>根據參與者填答的回饋內容，針對「框架」、「心法」、「案例分享」等內容頗受好評，也有不少人反映後續可以延續此次活動主題，多邀請不同產業的 PM 來做經驗分享，這方面我們會納入考慮，作為下次活動的備選清單。</p>
<hr>
<p>綜上所述，為我個人對此次活動的淺見，希望有參與活動的大家都有所收穫！<br>如果有任何建議與指正，也歡迎留言告訴我！</p>
]]></content>
      <categories>
        <category>活動後記</category>
      </categories>
      <tags>
        <tag>PM</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Hexo 與 GitPage 建置個人 Blog</title>
    <url>/2021/09/09/teach-hexo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介紹如何使用 Hexo 來製作個人 Blog，並利用 GitPage 進行自動更新部署，讓沒接觸過新手小白也能輕鬆上手。</p>
<h2 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h2><p>在開始之前，須先：</p>
<ul>
<li>安裝 <a href="https://nodejs.org/en/">Node.js</a></li>
<li>安裝 <a href="https://git-scm.com/">Git</a></li>
<li>註冊 <a href="https://github.com/">GitHub</a> 帳號</li>
<li>瞭解 cmd 或 bash 指令（下文中所有以 ‘$’ 為開頭的，皆為 bash 指令）</li>
</ul>
<h2 id="建置-Hexo"><a href="#建置-Hexo" class="headerlink" title="建置 Hexo"></a>建置 Hexo</h2><h3 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h3><p>使用 npm 來安裝 hexo （須先安裝 Node.js）</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure>

<p>安裝成功後，輸入以下指令可查看版本。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*OUtcy0m_9ASKBBHJS__9jg.png"></p>
<h3 id="安裝-Hexo-Git"><a href="#安裝-Hexo-Git" class="headerlink" title="安裝 Hexo Git"></a>安裝 Hexo Git</h3><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure>

<p>接下來即可初始化我們的部落格了。</p>
<p>執行下方指令，Hexo 就會在指定資料夾 <folder> 新增所需的檔案。</folder></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">hexo init <span class="hljs-variable">&lt;folder&gt;</span>   <span class="hljs-comment"># 初始化 blog 資料夾（自己命名）</span><br>cd <span class="hljs-variable">&lt;folder&gt;</span>          <span class="hljs-comment"># 移動到剛創建的 blog 資料夾裡</span><br>npm install          <span class="hljs-comment"># 安裝相關套件</span><br></code></pre></td></tr></table></figure>

<p>安裝完成之後，docs 的目錄結構如下：</p>
<ul>
<li><code>_config.yml</code> 網站 全域配置 檔案，可以在此設置大部分的設定，其設定是用 yaml 格式編寫。</li>
<li><code>package.json</code> Node.js 的套件版本控制。</li>
<li><code>scaffolds</code> Hexo 釋出文章的時候使用，建立新文章時，會根據 scaffold 來建立檔案。</li>
<li><code>source</code> MarkDown 和各種原始檔，放置內容的地方。</li>
<li><code>themes</code> Hexo 的主題資料夾，會根據主題來產生靜態檔案。</li>
</ul>
<h3 id="本地端啟動"><a href="#本地端啟動" class="headerlink" title="本地端啟動"></a>本地端啟動</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure>

<p>亦可用 <code>hexo g</code>，產生靜態檔案，會在目錄下產生 public 資料夾。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure>

<p>亦可用 <code>hexo s</code>，啟動伺服器，預設是 <code>http://localhost:4000/</code></p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure>

<p>亦可用 <code>hexo d</code>，部署網站。（ 如：github、heroku 等 ）</p>
<p>完成上述步驟後，在瀏覽器中即可看到本地端啟動的個人網頁了。</p>
<h2 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h2><h3 id="新建-GitHub-Repository"><a href="#新建-GitHub-Repository" class="headerlink" title="新建 GitHub Repository"></a>新建 GitHub Repository</h3><p>接著，我們可以在 Github 的主分支上來建立我們的文件了。有兩種方式可以達成：</p>
<ul>
<li>在一個已存在的專案中建立文件</li>
<li>建立一個新的專案 <a href="https://github.com/new">Create a new repository</a></li>
</ul>
<p>簡單起見，假設我們新建立了一個名為 <code>yourname.github.io</code> 的倉庫（repository），當然你也可以用一個已經存在的專案繼續下面的操作。</p>
<p><img src="https://miro.medium.com/max/1400/1*-mmXEsYov4s11mpPSvu0yA.png"></p>
<p style="text-align:center"><i>請將上面的 yourname 替換成你 GitHub 的帳號名稱</i></p>

<p><img src="https://miro.medium.com/max/1400/1*cOqn6zvl5jWSGLqinnhuAw.png"></p>
<p style="text-align:center"><i>創建完新 repo 的畫面</i></p>

<p>再來，到已創立的指定資料夾 <folder>中找一個 <code>_config.yml</code> 的檔案。</folder></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Site</span><br><span class="hljs-symbol">title:</span> /標題(會顯示在網頁標題與頁首)/<br><span class="hljs-symbol">subtitle:</span> /子標題(顯示在頁首)/<br><span class="hljs-symbol">description:</span> /內容描述(給搜尋引擎看的)/<br><span class="hljs-symbol">author:</span> /作者(顯示在頁尾)/<br><span class="hljs-symbol">language:</span> /網站預設語言(台灣:zh-tw)/<br><span class="hljs-symbol">timezone:</span> /時區(預設使用你電腦的時區)/<br><br><span class="hljs-meta"># URL</span><br><span class="hljs-symbol">url:</span> /網站的網域位址/<br><span class="hljs-symbol">root:</span> /網站根目錄/<br><span class="hljs-symbol">permalink:</span> /文章目錄(預設使用 YYYY\MM\DD\文章名稱)/<br><br><span class="hljs-meta"># Extensions</span><br><span class="hljs-symbol">theme:</span> /網站的佈景主題/<span class="hljs-meta"># Deployment</span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"> type:</span> /發佈型態/ <br><span class="hljs-symbol"> repository:</span> /部署位置/ <br><span class="hljs-symbol"> branch:</span> /分支/<br><span class="hljs-symbol"> message:</span> /部署訊息/<br></code></pre></td></tr></table></figure>

<p>開啟之後，拉到檔案最底部，可以看到</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"> type:</span><br></code></pre></td></tr></table></figure>

<p>將以下資訊對應輸入</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"> type:</span> git<br><span class="hljs-symbol"> repository:</span> http:<span class="hljs-comment">//github.com/yourname/yourname.github.io.git</span><br><span class="hljs-symbol"> branch:</span> master<br></code></pre></td></tr></table></figure>

<blockquote>
<p><b>注意：</b><br>設定中的 : 後一定要有一個空格<br>將上面的 yourname 改成你的 GitHub 帳號名稱</p>
</blockquote>
<h3 id="連線上傳-GitHub"><a href="#連線上傳-GitHub" class="headerlink" title="連線上傳 GitHub"></a>連線上傳 GitHub</h3><blockquote>
<p>過程中，可能會需要輸入GitHub的帳號、密碼做授權。</p>
</blockquote>
<p>使用下方的命令在本地 clone 專案：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">http</span>://github.com/yourname/yourname.github.io.git<br></code></pre></td></tr></table></figure>

<p>將 <code>USERNAME</code> 替換為你的使用者名稱，<code>REPOSITORY</code> 替換為你的專案名稱。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure>

<p>為 commit 留註解。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">$ git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m “<span class="hljs-keyword">first</span> <span class="hljs-keyword">commit</span>”<br></code></pre></td></tr></table></figure>

<p>手動新增 GitHub 遠端 branch 名稱、連結</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ git remote origin  http:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/yourname/y</span>ourname.github.io.git<br></code></pre></td></tr></table></figure>

<p>推到你的 GitHub master。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br># 只有第一次 <span class="hljs-built_in">push</span> 需要全打，第二次以後執行 git <span class="hljs-built_in">push</span> 即可<br></code></pre></td></tr></table></figure>

<p>這樣就把本地的檔案上傳到 GitHub 囉！</p>
<h3 id="設定-GitPage"><a href="#設定-GitPage" class="headerlink" title="設定 GitPage"></a>設定 GitPage</h3><p>打開 GitHub 專案的 Setting，下面有個 GitHub Page 的地方，將其勾選設定，接著就可以在你個人的 <a href="https://yourname.github.io/">https://yourname.github.io/</a> 看到畫面了。</p>
<p><img src="https://miro.medium.com/max/1400/1*fbLuA1K6Vik-ezAiUbAuJA.jpeg"></p>
<h2 id="設定專屬個人-Domain"><a href="#設定專屬個人-Domain" class="headerlink" title="設定專屬個人 Domain"></a>設定專屬個人 Domain</h2><p>有了個人的 GitHub Page 後，若想把網址換成專屬網域名稱，提供以下兩個網站可供參考：</p>
<ol>
<li>Gandi.net</li>
<li>Godaddy</li>
</ol>
<p>進去網站後，挑選並確定了自己想購買的網址後，在購物車結帳頁面可以選擇自己想要購買的年限，至少要買一年，若一年後還要再使用可以自行續約。</p>
<p>以 Gandi.net 為例，購買後，到 域名－區域檔紀錄－新增</p>
<p><img src="https://miro.medium.com/max/1400/1*Yjbd4zMuUMw2n56nJysL-Q.png"></p>
<p style="text-align:center"><i>新增紅框中的四筆 DNS</i></p>

<p>新增 DNS 紀錄 （可參考 <a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site">GitHub Page 官方說明文件</a></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">類型： A<br>TTL： <span class="hljs-number">1800</span><br>IPv4： <br><span class="hljs-number">185.199.108.153</span><br><span class="hljs-number">185.199.109.153</span><br><span class="hljs-number">185.199.110.153</span><br><span class="hljs-number">185.199.111.153</span><br></code></pre></td></tr></table></figure>

<p>再來，到 GitHub 的 Setting，Custom Domain 欄位輸入購買的網址，按儲存就設定完成了。</p>
<blockquote>
<p>小建議，下方的 HTTPS 也一同勾選。</p>
</blockquote>
<p><img src="https://miro.medium.com/max/1400/1*895UBYgeMPzh1OjOyQlgRA.png"></p>
<p>稍待一陣子，就可以用新購買的網址進入個人網站囉。</p>
<h2 id="更換主題"><a href="#更換主題" class="headerlink" title="更換主題"></a>更換主題</h2><p>Hexo 預設的主題是 <a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a>，而我們可以到 <a href="https://hexo.io/themes/">Hexo主題庫</a> 來挑選我們欲安裝的主題，以下以 <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a> 為例。</p>
<h3 id="安裝-Ocean"><a href="#安裝-Ocean" class="headerlink" title="安裝 Ocean"></a>安裝 Ocean</h3><p>安裝 Ocean</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean</span><br></code></pre></td></tr></table></figure>

<p>修改網站設定 <code>&lt;folder&gt;/ _config.yml</code></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> ocean<br></code></pre></td></tr></table></figure>

<p>在 <code>&lt;folder&gt;/theme/ocean/</code> 裡面的 <code>_config.yml</code> 也可以自己設定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Menu</span><br><span class="hljs-attr">menu:</span><br>  <span class="hljs-attr">Home:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">Archives:</span> <span class="hljs-string">/archives</span><br>  <span class="hljs-attr">Gallery:</span> <span class="hljs-string">/gallery</span><br>  <span class="hljs-attr">About:</span> <span class="hljs-string">/about</span><br>  <span class="hljs-attr">Links:</span> <span class="hljs-string">/links</span><br><span class="hljs-attr">rss:</span> <span class="hljs-string">/atom.xml</span><br><br><span class="hljs-comment"># Miscellaneous</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/favicon.ico</span><br><span class="hljs-attr">brand:</span> <span class="hljs-string">/images/hexo.svg</span><br><br><span class="hljs-comment"># Ocean Video</span><br><span class="hljs-comment"># Because I put videos in multiple formats on the same path, I just labeled the path here.</span><br><span class="hljs-attr">ocean:</span><br>  <span class="hljs-attr">overlay:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">images/ocean/</span>      <span class="hljs-comment"># Video storage path, formats: mp4/ogg/webm</span><br>  <span class="hljs-attr">brand:</span> <span class="hljs-string">/images/hexo-inverted.svg</span>      <span class="hljs-comment"># Optional, a small logo</span><br><br><span class="hljs-comment"># Content</span><br><span class="hljs-attr">excerpt_link:</span> <span class="hljs-string">Read</span> <span class="hljs-string">More...</span><br><br><span class="hljs-comment"># fancybox</span><br><span class="hljs-attr">fancybox:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Local search</span><br><span class="hljs-attr">search_text:</span> <span class="hljs-string">Search</span><br><br><span class="hljs-comment"># Gitalk</span><br><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">clientID:</span> <span class="hljs-comment"># GitHub Application Client ID</span><br>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-comment"># Client Secret</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-comment"># Repository name</span><br>  <span class="hljs-attr">owner:</span> <span class="hljs-comment"># GitHub ID</span><br>  <span class="hljs-attr">admin:</span> <span class="hljs-comment"># GitHub ID</span><br><br><span class="hljs-comment"># Valine</span><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># Default: false.</span><br>  <span class="hljs-attr">el:</span> <span class="hljs-string">&#x27;vcomments&#x27;</span>    <span class="hljs-comment"># The DOM element to be mounted on initialization.</span><br>  <span class="hljs-attr">appId:</span>    <span class="hljs-comment"># Application appId from Leancloud.</span><br>  <span class="hljs-attr">appKey:</span>    <span class="hljs-comment"># Application appKey from Leancloud.</span><br>  <span class="hljs-attr">notify:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># Mail notifier, Default: false.</span><br>  <span class="hljs-attr">verify:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment"># Validation code, Default: true.</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;mp&#x27;</span>    <span class="hljs-comment"># Gravatar type.</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-string">&#x27;10&#x27;</span>    <span class="hljs-comment"># Number of pages per page.</span><br>  <span class="hljs-attr">placeholder:</span> <span class="hljs-string">&#x27;請輸入...&#x27;</span>    <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>

<p>重新啟動 server</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure>

<p>這樣就更改成功了！</p>
<p><img src="https://miro.medium.com/max/1400/1*0Ji-3ir8nokLgZGvtzKVIw.png"></p>
<p style="text-align:center"><i>修改後的 Ocean 主題</i></p>

<h2 id="發佈文章"><a href="#發佈文章" class="headerlink" title="發佈文章"></a>發佈文章</h2><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure>

<p>你可以在指令中指定文章的佈局（layout），預設為 post ，也可以透過修改 <code>_config.yml</code> 中的 <code>default_layout</code> 設定來指定預設佈局。</p>
<h3 id="佈局（Layout）"><a href="#佈局（Layout）" class="headerlink" title="佈局（Layout）"></a>佈局（Layout）</h3><p>Hexo 有三種預設佈局：post、page 和 draft，它們分別對應不同的路徑，而你所自定的其他佈局和 post 相同，都儲存至 source&#x2F;_posts 資料夾。</p>
<p><img src="https://miro.medium.com/max/824/1*eFVpwYyoIyZZ2x19f8r8Pw.png"></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type"></span>“postName”         <span class="hljs-meta"># 新建文章</span><br>$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> “pageName”    <span class="hljs-meta"># 新建頁面</span><br>$ hexo publish “draftName”    <span class="hljs-meta"># 新建草稿</span><br></code></pre></td></tr></table></figure>

<h3 id="刪除文章"><a href="#刪除文章" class="headerlink" title="刪除文章"></a>刪除文章</h3><p>首先進入到 <code>source /_post</code> 資料夾中，找到 <code>helloworld.md</code>，在本地直接執行刪除。</p>
<p><img src="https://miro.medium.com/max/1400/0*q6PVwd41rT6-e47s.png"></p>
<p>執行以下操作，一段時間後就會發現文章已刪除。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">$ hexo clean       # 清除快取檔案和已產生的靜態檔案。<br>$ hexo d -g        # d = deploy, g = <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure>

<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span><br><span class="hljs-meta"># 如果 port:4000 被佔用，可以用這個$ hexo render &lt;file1&gt; [file2] </span><br><span class="hljs-meta"># 將文件渲染成靜態頁面</span><br></code></pre></td></tr></table></figure>

<p>附錄：<a href="https://hexo.io/docs/">Hexo 官方參考文件</a></p>
]]></content>
      <categories>
        <category>技術筆記</category>
      </categories>
      <tags>
        <tag>教學</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 宣告變數： var／ let / const 差異</title>
    <url>/2021/10/10/var-const/</url>
    <content><![CDATA[<p>如果你像我一樣開始學 JS，多少會有個疑惑：</p>
<blockquote>
<p>學習時是用 let &#x2F; const 宣告變數，怎麼網路上查詢的 JS 程式碼，有些是用 var 宣告變數的呢？到底它們之間有什麼差異？</p>
</blockquote>
<h2 id="ES6-後，從-var-到-let-const"><a href="#ES6-後，從-var-到-let-const" class="headerlink" title="ES6 後，從 var 到 let &#x2F; const"></a>ES6 後，從 var 到 let &#x2F; const</h2><p>目前 JavaScript 主流是 ES6 版本，在這個版本中，是推薦使用 let 和 const 宣告變數，而在網上查詢的資料，很可能是 ES6 版本前撰寫的程式碼，那時候宣告變數的方式還是用 var 語法，才會導致上述疑惑的現象。</p>
<h4 id="var-與-let-const-，主要有幾項差異："><a href="#var-與-let-const-，主要有幾項差異：" class="headerlink" title="var 與 let &#x2F; const ，主要有幾項差異："></a>var 與 let &#x2F; const ，主要有幾項差異：</h4><ul>
<li>作用域 (scope) 不同</li>
<li>for 迴圈的綁定 (bind) 差異</li>
<li>變量提升 (hoisting) 不同</li>
<li>重複宣告的差異</li>
</ul>
<p>這些改變的主要好處是： <u>讓 JS 變數的操作更加嚴謹</u>，減少不直覺、出錯或重複宣告的可能性，藉此讓多人或個人大型開發更順利。</p>
<h2 id="var-是函式作用域，let-const-是區塊作用域"><a href="#var-是函式作用域，let-const-是區塊作用域" class="headerlink" title="var 是函式作用域，let &#x2F; const 是區塊作用域"></a>var 是函式作用域，let &#x2F; const 是區塊作用域</h2><p>在 ES6 前，並沒有區塊作用域（block scope）的概念，僅有全域（global scope）與函式作用域（function scope），所以 var 宣告的變數，具有函式作用域（function scope）的性質，代表切分最小單位的有效範圍是 function。</p>
<p>直到 ES6 後，新增區塊（ <code>&#123; &#125; 大括號範圍</code> ）切分的概念， let &#x2F; const 宣告的變數，才具有區塊作用域（block scope）的性質，切分最小單位的有效範圍是 blcok。</p>
<p>而所謂的作用域就是 「變數有效的作用範圍」，最大為全域作用範圍，意指變數有效範圍是全部範圍。</p>
<blockquote>
<p><strong>綜合整理：</strong></p>
<ul>
<li>var 具有「函式作用域」，亦即在函式中宣告的變數，有效作用範圍會被限制在該函式中。但不具有區塊作用域，所以<u>在區塊中宣告的變數，依然會作用到區塊之外，並不會被區塊限制住</u>。</li>
<li>let &#x2F; const 具有「區塊作用域」，亦即<u>在區塊中宣告的變數，有效作用範圍會被限制在該區塊中</u>。</li>
</ul>
</blockquote>
<p>可以先來看看下方的例子。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/// 「var」 不受區塊限制，區塊外變數存取成功。///</span><br><br>&#123;<br>  <span class="hljs-keyword">var</span> corgiDogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(corgiDogName);<br><span class="hljs-comment">// 吐司</span><br><br><span class="hljs-comment">///「let」會受區塊限制，區塊外變數存取失敗。///</span><br>&#123;<br>  <span class="hljs-keyword">let</span> corgiDogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(corgiDogName);<br><span class="hljs-comment">// ReferenceError: corgiName is not defined</span><br></code></pre></td></tr></table></figure>

<p>雖然 var 不受區塊限制，但會受到函式範圍限制，如下:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/// 「var」 受函式限制，函式外變數存取失敗。///</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callCorgi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> corgiDogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(corgiDogName);<br><span class="hljs-comment">// ReferenceError: corgiDogName is not defined</span><br><br><span class="hljs-comment">/// 即使用 var 宣告相同的變數名稱 dogName，但因為「 函式作用域 」，所以不會讓同名變數衝突。 ///</span><br><br><span class="hljs-comment">// 將柯基犬命名為吐司，之後用 callCargi() 呼叫</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callCargi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> dogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dogName);<br>&#125;<br><br><span class="hljs-comment">// 將米克斯犬命名為厚片，之後用 callMix() 呼叫</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callMix</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> dogName = <span class="hljs-string">&#x27;厚片&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dogName);<br>&#125;<br><br><span class="hljs-title function_">callCargi</span>(); <span class="hljs-comment">// 吐司</span><br><span class="hljs-title function_">callMix</span>(); <span class="hljs-comment">// 厚片</span><br></code></pre></td></tr></table></figure>

<p>由上述範例，可以看出限定作用域範圍有兩個好處：</p>
<ul>
<li>避免同名變數的衝突。</li>
<li>能維持最小權限的原則，以避免變數資料被不當存取。</li>
</ul>
<p>而過往用 var 宣告，僅有 function 函式範圍有這樣的好處，而如今用 let &#x2F; const 宣告，就能讓上述好處發生在 if、for 等「 區塊作用域 」當中，藉此降低多人協作或大型專案的衝突情況。</p>
<h2 id="var-與-let-，for-迴圈的綁定（bind）差異"><a href="#var-與-let-，for-迴圈的綁定（bind）差異" class="headerlink" title="var 與 let ，for 迴圈的綁定（bind）差異"></a>var 與 let ，for 迴圈的綁定（bind）差異</h2><p>讓我們用一個經典案例作為第二部分的開場。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/// 用 for 迴圈執行五次，每隔 0.1 秒會印出 i ///</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你覺得上述的程式執行的結果為何？</p>
<p>（Ａ） 0 、 1 、 2 （Ｂ） 3 、 3 、 3</p>
<p>是不是 A 啊 ～ No ～ No ～ No ～ 其實是 B 哦。</p>
<hr>
<p>我想很多沒學過 var 的人，包括我，都會直覺性的選擇 A ，因為如果我們學的是 let ，而將 var 替換成 let ，答案就會是 A ，這不是更符合 for 的效用嗎！！！ 可惜事與願違，真正執行的結果會是 B。</p>
<p>上述預期結果應該是 0 1 2 ，卻莫名變成 3 3 3，正與宣告變數語法 var &#x2F; let 有關。究竟怎麼了？</p>
<p>要解釋這個問題，要分成兩點討論：</p>
<ol>
<li>setTimeout() 的時間延遲，與 function 中 console.log(i) 的「 執行時間點 」。</li>
<li>function 中 console.log(i) 的「 值怎麼來 」的。</li>
</ol>
<p>首先來看第一點，當進入 for 迴圈時，宣告變數 <code>var i = 0</code> ，並開始條件判斷，當 <code>i &lt; 3 </code>時， <code>i + 1</code>，執行完後，接著需要等待 0.1 秒的時間，才會進行 <code>setTimeout()</code> 內的 <code>function() &#123; console.log( i ) ; &#125;</code>。</p>
<p>而 JavaScript 是「異步&#x2F;非同步」語言，因此在等待執行 <code>function() &#123; console.log( i ) ; &#125;</code> 前的這 0.1 秒內，會先執行完已經能執行的 for 迴圈。</p>
<p>所以現在能理解第一點的結論： <code>function</code> 中，<code>console.log( i )</code> 的執行時間點會在 for 迴圈執行完畢之後。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">///因為非同步與延遲時間，所以會先執行完 for 迴圈後，才執行 function。///</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-comment">// for 迴圈正在 murmur : 還要等你 setTimeout 0.1 秒，不如我先做一做，不要浪費時間。</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-comment">// 3 3 3</span><br></code></pre></td></tr></table></figure>

<p>澄清一下，目前為止所提的第一點，其實與 var 和 let 的差異是沒關係的，只是說明非同步和時間點的狀況。接著進入到第二點，console.log(i) 的值是怎麼來的，這就與 var 和 let 的差異有關了。</p>
<p>var 是函式作用域，這段 for 迴圈程式碼外沒有任何包覆，所以 var 所宣告的 i 會存在於全域 window (瀏覽器) 當中，且只會被綁定（bind）一次，也可以說是共用一個 instance。</p>
<p>加上 for 迴圈會先跑完，才 console.log( i )，所以最後 console.log( i ) 的值會才會是 3。</p>
<p>至於 let 則是「 區塊作用域 」每次 i 都會被紀錄在創造出來的區域中，更精確地說，是每次迭代都會建立一個新的環境（context），而這個環境會紀錄當下的變數 i 值，不會覆蓋掉上一個環境裡面的變數值，因此可以產生多個 i 值。。</p>
<p>可以看下方的示意圖，來便於理解「整體概念」，但細節上可能有出入。</p>
<p><img src="https://i.imgur.com/PQ05GIL.png"></p>
<p>讓們適時地整理一下，在 for 迴圈中，</p>
<ul>
<li>var 的情況只會綁定一次，而且不具區塊作用域，最終會只有一個值存在於全域中（以此例而言），也可以說只有一個 instance。</li>
<li>let 的情況會發生重複綁定，而且具有區塊作用域，或者說多個紀錄變數的環境，最終會有多的值存在於 for 迴圈區塊中，也可以說會有多個 instance。</li>
</ul>
<p>就實作而言，雖然僅有 var 的情況下也可以用「立即呼叫執行函式 IIFE」處理這樣的狀況，但較為複雜且不直覺，改用 let 後，就能簡單處理，且能更直覺地知道 for 迴圈結果啦！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">///將 var i 改為 let i 後，輕易解決問題。///</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-comment">// 0 1 2</span><br><br><span class="hljs-comment">///不改 var i 的情況下，以 IIFE 相對複雜且不直覺。///</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    &#125;, <span class="hljs-number">100</span> * x);<br>  &#125;)(i);<br>&#125;<br><span class="hljs-comment">// 0 1 2</span><br></code></pre></td></tr></table></figure>

<h2 id="var-的提升與-let-const-不同"><a href="#var-的提升與-let-const-不同" class="headerlink" title="var 的提升與 let &#x2F; const 不同"></a>var 的提升與 let &#x2F; const 不同</h2><p>讓我們再次以一個問題開始 :</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>你覺得上述的程式執行的結果為何？</p>
<ul>
<li>（Ａ） 5</li>
<li>（Ｂ） ReferenceError</li>
<li>（Ｃ） undefined</li>
</ul>
<p>可以想一下 XD</p>
<blockquote>
<p>如果你跟我一樣比較少使用 var ，常使用 let 的話，應該會認為是（Ｂ） ReferenceError。</p>
<p>當然，不會那麼容易，印出來的結果其實是 （Ｃ） undefined。</p>
</blockquote>
<p>非常不直覺啊…，因為 undefined 代表找不到值，已經被宣告，但尚未賦值，而 ReferenceError 則表示根本找不到 i ，尚未宣告。所以一般而言，會預期上述程式碼結果應該為「尚未宣告變數的ReferenceError」。</p>
<p>但以結果來說，卻是印出 undefined ，即是代表：雖然我們看不見，但其實在 <code>console.log(i)</code> 之前，i 就已經被宣告了，只是尚未賦值。</p>
<p>是不是頗違反直覺，因為 console.log(i) 前，根本沒有程式碼…。上述狀況，我們可以想像成下面這段程式碼來表示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">///由於 var 直接變量提升，所以上面程式碼等同下面程式碼///</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//undefined</span><br><br><span class="hljs-keyword">var</span> i;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>i = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure>

<p>這其中是因為 var 有著「提升（hoisting）」的特性，其實不僅是 var ，function 也有這個特性。</p>
<p>以 var 宣告變數而言，「 變數提升 」簡而言之是：在執行任何程式碼前，會把變數放進記憶體中，這樣的特點是，可以在程式碼宣告該變數之前使用它。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/// 因為 hoisting，所以可以在宣告變數前，就預先使用變數，所以可以寫完後一起宣告///</span><br><br>i = <span class="hljs-number">2</span>;<br>n = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i + n);<br><span class="hljs-keyword">var</span> i;<br><span class="hljs-keyword">var</span> n;<br><span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<p>在這樣的情況下，只需要有賦值就不會出錯，即使尚未宣告變數也不會出錯。</p>
<p>這樣會造成什麼問題？當養成了「 後宣告 」的習慣，如果最後忘了用 var 宣告呢？並不會出錯，只是變數會跑到全域中，變成全域變數，可能造成些 bug，像是：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/// 函式中沒有用 var 宣告，導致污染到全域 ///</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addFunc</span>(<span class="hljs-params">y</span>) &#123;<br>  x = <span class="hljs-number">100</span>;<br>  x = x + y;<br>&#125;<br><br><span class="hljs-title function_">addFunc</span>(<span class="hljs-number">50</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br><span class="hljs-comment">// 150，預期應該要是 1，但函式中的 x 跑出來了</span><br></code></pre></td></tr></table></figure>

<p>而 <code>let</code> 與 <code>const</code> 則不會，而是會進到 暫時死區 (TDZ)，因此在 <code>let</code> 與 <code>const</code> 宣告變數前使用該變數，會出現錯誤：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// Uncaught ReferenceError: greeting is not defined</span><br><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">&quot;hi there&quot;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="var-允許重複宣告，let-const-會出錯"><a href="#var-允許重複宣告，let-const-會出錯" class="headerlink" title="var 允許重複宣告，let &#x2F; const 會出錯"></a>var 允許重複宣告，let &#x2F; const 會出錯</h2><p>最後再提一個能幫助防止開發錯誤或衝突的小地方，就是用 var 可以重複宣告同樣名稱的變數，而 let &#x2F; const 如果重複宣告同名變數會出錯。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> myDogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br><span class="hljs-keyword">var</span> myDogName = <span class="hljs-string">&#x27;厚片&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDogName);<br><span class="hljs-comment">// 厚片</span><br><br><span class="hljs-keyword">let</span> myDogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br><span class="hljs-keyword">let</span> myDogName = <span class="hljs-string">&#x27;厚片&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDogName);<br><span class="hljs-comment">// SyntaxError: Identifier &#x27;myDogName&#x27; has already been declared</span><br><br><span class="hljs-keyword">const</span> myDogName = <span class="hljs-string">&#x27;吐司&#x27;</span>;<br><span class="hljs-keyword">const</span> myDogName = <span class="hljs-string">&#x27;厚片&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDogName);<br><span class="hljs-comment">// SyntaxError: Identifier &#x27;myDogName&#x27; has already been declared</span><br></code></pre></td></tr></table></figure>

<p>這點對初學者或多人學做而言更能防止錯誤、容易尋找到錯誤所在。</p>
<h2 id="var-與-let-const-差異總結"><a href="#var-與-let-const-差異總結" class="headerlink" title="var 與 let &#x2F; const 差異總結"></a>var 與 let &#x2F; const 差異總結</h2><h4 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h4><ul>
<li>區域作用域（Function-Scope）：<code>let</code>、<code>const</code> 在區域內才能使用，離開宣告的區域就無法取得資料。</li>
<li>函式作用域（Block-Scope）：<code>var</code> 依函示決定作用域。</li>
<li>向上提升（Hoisting）：因為 JavaScript 是依順序執行，若在宣告變數前先執行變數，宣告的變數會提升到最上面，優先宣告變數。</li>
</ul>
<h4 id="統整"><a href="#統整" class="headerlink" title="統整"></a>統整</h4><table>
<thead>
<tr>
<th>變數</th>
<th>Function-Scope 函式作用域 &#x2F; Global-Scope</th>
<th>Block-Scope 區域作用域</th>
<th>Reassignable 重複定義</th>
<th>Redeclarable 重複宣告</th>
</tr>
</thead>
<tbody><tr>
<td>const</td>
<td>Ｘ</td>
<td>Ｖ</td>
<td>Ｘ</td>
<td>Ｘ</td>
</tr>
<tr>
<td>Let</td>
<td>Ｘ</td>
<td>Ｖ</td>
<td>Ｖ</td>
<td>Ｘ</td>
</tr>
<tr>
<td>Var</td>
<td>Ｖ</td>
<td>Ｘ</td>
<td>Ｖ</td>
<td>Ｖ</td>
</tr>
</tbody></table>
<ul>
<li>var：ES5 新增的方法，屬於 Function Scope 全域變數，定義後的變數可以被修改，但後來很少人用。</li>
<li>let： ES6 後新增的方法，屬於 Block Scope 區域變數，定義後的變數可以被修改</li>
<li>const：ES6 後新增的方法，屬於 Block Scope 區域變數，定義後的變數不可以被修改</li>
</ul>
<hr>
<p>綜合來說就是 let&#x2F;const 將宣告變數變得更加嚴謹，藉此增加易讀性、防止出錯，而最重要的 CTA ，我想就是：</p>
<blockquote>
<p>在 JS 中，不要再用 var ，請都使用 let &#x2F; const 宣告變數吧！</p>
</blockquote>
]]></content>
      <categories>
        <category>技術筆記</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Studies</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket 介紹與使用</title>
    <url>/2023/08/22/webSocket/</url>
    <content><![CDATA[<p>在介紹 WebSocket 之前，先來了解幾個 HTTP 的連線方式。</p>
<h2 id="HTTP-的連線方式"><a href="#HTTP-的連線方式" class="headerlink" title="HTTP 的連線方式"></a>HTTP 的連線方式</h2><h3 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h3><p>這種方式是早期透過 Javascript 定時（<code>setInterval</code>、<code>setTimeout</code>）來向後端請求最新資料並呈現於頁面之上， 這麼做的好處是容易實現， 但我們並不知曉 Server 端何時會更新， 只能<strong>傻傻的定時獲取</strong>， 造成的影響就是<U>頻寬的浪費及資料呈現不即時</U>。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1382/1*HJww54OsxD5D3Cn5YyJunQ.png"></p>
<h3 id="Long-Polling（長時間輪詢）"><a href="#Long-Polling（長時間輪詢）" class="headerlink" title="Long-Polling（長時間輪詢）"></a>Long-Polling（長時間輪詢）</h3><p>這種方式就是收到前端請求後，Server 端會等待， 若這段時間有資料就會將最新資料回傳給前端， 因此等待的這段期間 Client 什麼事情也不用做，等待資料回傳後再發送下一個請求， 雖然長時間的連接解決了 Polling 開銷的問題，<u>但如果在更新資料很頻繁的狀況下，也會造成連續的 Polling 的動作產生，<strong>效能未必較佳</strong></u>。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1204/1*kseayTfoDyTzI8uFSen9Cg.png"></p>
<h3 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server Sent Events"></a>Server Sent Events</h3><p>簡單來說就是 <u><strong>伺服端單向的推送資料給瀏覽器</strong></u>，實作起來相對容易。<br>但這種方式較少被使用，  因為 SSE 能做的功能 Websocket 也能完成， 差別只是雙向溝通還是單向溝通而已。<br>不過在某些應用上，瀏覽器不太需要主動發送資料給 Server 端（例：股市行情、即時新聞…），只需要接收 Server 端的最新資料即可，就適合使用。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*9akWJheWpyJuTvo6AfoEow.png"></p>
<h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p>以上幾個方式的共同點就是都基於 HTTP 進行傳輸，而我們也知道 HTTP 的傳輸為了確保正確性會帶有較多的標頭…等資訊；而 <strong>Websocket 只有一開始確定連線時會走 HTTP 以外，之後的傳輸都不是基於 HTTP</strong>，在傳輸上會來的更有效率，且提供了<strong>雙向溝通</strong>的功能，避免延遲，因此需要即時互動的應用就非常適合使用 Websocket 的方式來進行實作。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1106/1*xPnOxyaKv5NleFy_13kCqg.png"></p>
<h2 id="WebSocket-和-HTTP-的差異"><a href="#WebSocket-和-HTTP-的差異" class="headerlink" title="WebSocket 和 HTTP 的差異"></a>WebSocket 和 HTTP 的差異</h2><p>和 <code>HTTP</code> 最大的差別是，<u><code>WebScoket</code> 在建立連線之後，可以實現 client 與 server 的雙向溝通機制</u>，也就是說，雙方可以即時的交換資訊，<u>不用再等待 client 發出請求，或使用佔用資源的輪詢方式來實現</u>。</p>
<p>另一方面，在建立連線之後就會持續保持著連線狀態，所以每次通訊時所發出的 message，就可以省略掉 headers 當中一些關於連線狀態的資訊，因而效率高了不少。</p>
<h3 id="WebSocket-與-HTTP-："><a href="#WebSocket-與-HTTP-：" class="headerlink" title="WebSocket 與 HTTP ："></a>WebSocket 與 HTTP ：</h3><ul>
<li>同屬於應用層， 都是基於 TCP 來進行連線傳輸</li>
<li>默認的 port 也是為 80 和 443，並透過同樣的 HTTP 3-way handshake 建立連線</li>
<li>與 HTTP 一樣可以進行加密傳輸， HTTP 的部份為 <code>https</code>， WebSocket 則為 <code>wss</code>。</li>
<li>但 WebSocket 真正傳輸資料時就不必經過 HTTP 的方式（要進行像是 HTTPS 當中的 SSL&#x2F;TLS 的加密安全傳輸，有 <code>WebSocket Secure</code> 協議可以使用）</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*Aefa0WHo_VsgQMjvj9rPFg.png"></p>
<h2 id="WebSocket-的使用"><a href="#WebSocket-的使用" class="headerlink" title="WebSocket 的使用"></a>WebSocket 的使用</h2><p>WebSocket 在使用上其實不難。<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">MDN</a> 上有關於 WebSocket API (client 端) 的範例。</p>
<p>這裡我們來簡單建立一下連線：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Create WebSocket connection.</span><br><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;wss://echo.websocket.org&quot;</span>);<br><br><span class="hljs-comment">// Connection opened</span><br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Open connection&#x27;</span>)<br>    socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// Listen for messages</span><br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Message from server: <span class="hljs-subst">$&#123;event.data&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果把上面這段程式碼貼到 DevTool 的 console 當中，就可以看到其連線運作。</p>
<p>內容其實相當簡單，首先建立 WebSocket 連線實例，接著，就可以監聽各種 events，像是</p>
<ul>
<li>open （連線開啟）</li>
<li>close （連線關閉）</li>
<li>error （連線錯誤）</li>
<li>message （連線訊息）</li>
</ul>
<p>之後，再根據不同的 events 做出不同的對應方式，譬如在畫面上呈現連線訊息等。</p>
<p>除了監聽事件之外，也可以透過 <code>socket.send()</code> 來送出資訊，以及 <code>send.close()</code> 來關閉連線。</p>
<p>MDN 上介紹的 WebSocket API 其實就可以幫助我們快速建立 <code>WebSocket</code> 連線，不過如果我們想要在自己的專案當中進行更複雜的操作，也可以找到很完整的套件來幫助我們（例如： <a href="https://socket.io/">socket.io</a>），可以同時用在 client 端與 server 端。</p>
<hr>
<p>有了 <code>WebSocket</code> 讓我們的應用程式可以和使用者有更多的互動，除了「聊天室」的應用之外，還有其他的應用場景像是「訊息推播」、「即時訊息更新」、「共同編輯」等等，應用相當廣泛。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/WebSocket#History">WebSocket</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket (MDN)</a></li>
</ul>
]]></content>
      <categories>
        <category>技術筆記</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
